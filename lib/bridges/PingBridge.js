// Generated by CoffeeScript 1.10.0
(function() {
  var BaseBridge, PingBridge,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseBridge = require('./BaseBridge');

  PingBridge = (function(superClass) {
    extend(PingBridge, superClass);


    /*
     * @protected
     * @type {boolean}
     */

    PingBridge.prototype._pinging = false;


    /*
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingIntervalMs = 60000;


    /*
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingTimeoutMs = 5000;


    /**
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingFailureLimit = 3;


    /**
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingFailureCount = 0;


    /**
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingIntervalId = 0;


    /**
     * @override
     */

    function PingBridge(parent, config, index) {
      this._onPong = bind(this._onPong, this);
      this._onPing = bind(this._onPing, this);
      this._pingTimeout = bind(this._pingTimeout, this);
      this._ping = bind(this._ping, this);
      this.connect = bind(this.connect, this);
      var ref, ref1, ref2, ref3, ref4, ref5;
      PingBridge.__super__.constructor.call(this, parent, config, index);
      this._pingIntervalMs = (ref = (ref1 = config.ping) != null ? ref1.interval : void 0) != null ? ref : this._pingIntervalMs;
      this._pingTimeoutMs = (ref2 = (ref3 = config.ping) != null ? ref3.timeout : void 0) != null ? ref2 : this._pingTimeoutMs;
      this._pingFailureLimit = (ref4 = (ref5 = config.ping) != null ? ref5.failureLimit : void 0) != null ? ref4 : this._pingFailureLimit;
      this.on('$ping', this._onPing);
      this.on('$pong', this._onPong);
    }


    /**
     * @override
     */

    PingBridge.prototype.connect = function() {
      this.log('info', "Ping setting, interval=" + this._pingIntervalMs + "ms timeout=" + this._pingTimeoutMs + "ms failureLimit=" + this._pingFailureLimit);
      return this._pingIntervalId = setInterval(this._ping, this._pingIntervalMs);
    };

    PingBridge.prototype._ping = function() {
      this.log('info', "Ping to bridge, waiting Pong...");
      if (!this._pinging) {
        this._widgetBridge.virtualWrite(0, '$ping');
      }
      this._pinging = true;
      return setTimeout(this._pingTimeout, this._pingTimeoutMs);
    };

    PingBridge.prototype._pingTimeout = function() {
      if (this._pinging) {
        this._pingFailureCount++;
        this.log('error', "Ping was no response, failure count " + this._pingFailureCount + " / " + this._pingFailureLimit + ".");
        this._pinging = false;
        if (this._pingFailureCount > this._pingFailureLimit) {
          this.log('error', "Ping failed " + this._pingFailureCount + " times, the bridge will stop.");
          clearInterval(this._pingIntervalId);
          return this.status = this.STATUS_TYPE.error;
        }
      }
    };

    PingBridge.prototype._onPing = function() {
      this.log('info', "Ping from bridge, response Pong.");
      return this._widgetBridge.virtualWrite(0, '$pong');
    };

    PingBridge.prototype._onPong = function() {
      this.log('info', "Pong from bridge.");
      this._pinging = false;
      return this._pingFailureCount = 0;
    };

    return PingBridge;

  })(BaseBridge);

  module.exports = PingBridge;

}).call(this);

//# sourceMappingURL=PingBridge.js.map
