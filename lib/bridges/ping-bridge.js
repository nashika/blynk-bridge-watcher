// Generated by CoffeeScript 1.10.0
(function() {
  var PingBridge, TransceiverBridge,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TransceiverBridge = require('./transceiver-bridge');

  PingBridge = (function(superClass) {
    extend(PingBridge, superClass);


    /*
     * @protected
     * @type {boolean}
     */

    PingBridge.prototype._pinging = false;


    /*
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingIntervalMs = 60000;


    /*
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingTimeoutMs = 5000;


    /**
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingFailureLimit = 3;


    /**
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingFailureCount = 0;


    /**
     * @protected
     * @type {number}
     */

    PingBridge.prototype._pingIntervalId = 0;


    /**
     * @override
     */

    function PingBridge(parent, config) {
      this._onPing = bind(this._onPing, this);
      this._pingTimeout = bind(this._pingTimeout, this);
      this._pingCallback = bind(this._pingCallback, this);
      this._ping = bind(this._ping, this);
      this.connect = bind(this.connect, this);
      PingBridge.__super__.constructor.call(this, parent, config);
      this._pingIntervalMs = this._checkConfig(config, 'ping.interval', 'number', this._pingIntervalMs);
      this._pingTimeoutMs = this._checkConfig(config, 'ping.timeout', 'number', this._pingTimeoutMs);
      this._pingFailureLimit = this._checkConfig(config, 'ping.failureLimit', 'number', this._pingFailureLimit);
      this.on('$ping', this._onPing);
    }


    /**
     * @override
     */

    PingBridge.prototype.connect = function() {
      PingBridge.__super__.connect.call(this);
      this.log('info', "Ping setting, interval=" + this._pingIntervalMs + "ms timeout=" + this._pingTimeoutMs + "ms failureLimit=" + this._pingFailureLimit);
      return this._pingIntervalId = setInterval(this._ping, this._pingIntervalMs);
    };

    PingBridge.prototype._ping = function() {
      if (this.status !== this.STATUS_TYPES.ready) {
        return;
      }
      this.log('info', "Ping to bridge, waiting Pong...");
      if (!this._pinging) {
        this.send('pi', this._pingCallback);
      }
      this._pinging = true;
      return setTimeout(this._pingTimeout, this._pingTimeoutMs);
    };

    PingBridge.prototype._pingCallback = function() {
      this.log('info', "Pong from bridge.");
      this._pinging = false;
      return this._pingFailureCount = 0;
    };

    PingBridge.prototype._pingTimeout = function() {
      if (this._pinging) {
        this._pingFailureCount++;
        this.log('error', "Ping was no response, failure count " + this._pingFailureCount + " / " + this._pingFailureLimit + ".");
        this._pinging = false;
        if (this._pingFailureCount >= this._pingFailureLimit) {
          this.log('error', "Ping failed " + this._pingFailureCount + " times, the bridge will stop.");
          clearInterval(this._pingIntervalId);
          return this.status = this.STATUS_TYPES.error;
        }
      }
    };

    PingBridge.prototype._onPing = function() {
      this.log('info', "Ping from bridge, response Pong.");
      return this.send('po');
    };

    return PingBridge;

  })(TransceiverBridge);

  module.exports = PingBridge;

}).call(this);

//# sourceMappingURL=ping-bridge.js.map
