// Generated by CoffeeScript 1.10.0
(function() {
  var Blynk, Board, Bridge, config, core,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  Blynk = require('blynk-library');

  core = require('./core');

  config = require('../config');

  Bridge = require('./Bridge');

  Board = (function() {

    /**
     * @public
     * @type {Blynk.Blynk}
     */
    Board.prototype.blynk = null;


    /**
     * @public
     * @type {Blynk.Blynk.VirtualPin}
     */

    Board.prototype.inputVPin = null;


    /**
     * @public
     * @type {Object.<Bridge>}
     */

    Board.prototype.bridges = null;


    /**
     * @constructor
     */

    function Board() {
      this._onInputVPin = bind(this._onInputVPin, this);
      this._onConnect = bind(this._onConnect, this);
      var bridgeConfig, i, j, len, ref;
      core.logger.debug("Auth dummy blynk board was started.");
      this.blynk = new Blynk.Blynk(config.board.token, {
        certs_path: './node_modules/blynk-library/certs/'
      });
      core.logger.debug("Construct Input Virtual Pin 0 was started.");
      this.inputVPin = new this.blynk.VirtualPin(0);
      core.logger.debug("Construct Input Virtual Pin 0 was finished.");
      core.logger.debug("Construct Bridge objects was started.");
      this.bridges = {};
      i = 1;
      ref = config.bridges;
      for (j = 0, len = ref.length; j < len; j++) {
        bridgeConfig = ref[j];
        this.bridges[bridgeConfig.name] = new Bridge(this, bridgeConfig, i++);
      }
      core.logger.debug("Construct Bridge objects was finished.");
      this.inputVPin.on('write', this._onInputVPin);
      this.blynk.on('connect', this._onConnect);
      core.logger.debug("Construct Notifier objects was started.");
      core.logger.debug("Construct Notifier objects was finished.");
    }

    Board.prototype._onConnect = function() {
      var bridgeConfig, j, len, ref, results;
      core.logger.debug("Auth dummy blynk board was finished.");
      ref = config.bridges;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        bridgeConfig = ref[j];
        results.push(this.bridges[bridgeConfig.name].connect());
      }
      return results;
    };

    Board.prototype._onInputVPin = function(param) {
      var bridgeName, eventArgs, eventName, params, ref;
      params = param[0].split(',');
      if (params.length < 2) {
        core.logger.error("Input data '" + param + "' is invalid format.");
        return;
      }
      bridgeName = params[0];
      eventName = params[1];
      eventArgs = params.splice(2);
      core.logger.debug("Receive input data, bridge='" + bridgeName + "' event='" + eventName + "' args=" + (JSON.stringify(eventArgs)));
      if (!this.bridges[bridgeName]) {
        core.logger.warn("Bridge '" + bridgeName + "' was not found.");
        return;
      }
      if (this.bridges[bridgeName].listeners(eventName).length === 0) {
        core.logger.warn("Bridge '" + bridgeName + "' not have '" + eventName + "' event.");
        return;
      }
      return (ref = this.bridges[bridgeName]).emit.apply(ref, [eventName].concat(slice.call(eventArgs)));
    };

    return Board;

  })();

  module.exports = Board;

}).call(this);

//# sourceMappingURL=Board.js.map
